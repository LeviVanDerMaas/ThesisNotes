# [`xsimd::dispatch<A>(F)`](https://xsimd.readthedocs.io/en/latest/api/dispatching.html)
Takes a functor `F` (a class that overrides the () operator) whose call operator takes (or should take, at least) an architecture parameter as the first argument, and an arbitrary number of `Args...` after that. Returns a "dispatching" functor that takes `Args...`; this functor will dynamically dispatch its call based on the architecture the code was compiled for and the architectures available at runtime.

You should declare `F`'s () operator as a template that takes itself two parameters `Arch` and `T`, this is so that `xsimd::dispatch<A>(F)` can generically use the functor instead of you needing to overload the () operator for each architecture you'll use. In template instantiations triggered by `xsimd::dispatch`, `Arch` should then become whatever `A` is, and `T` will be the return type of `F`'s () operator. *Doing it like this means you can use `F`'s () method template to describe the function you actually want to call in an architecture agnostic manner; the functor then produced by passing `F` to `xsimd::dispatch<A>` will handle executing the architecture-specfic instance of the function.*

You're not yet done now:  you should now declare `extern template` on `F's` () operator for each architecture and return type that you wish to provide a specific implementation for, wherever you wish to use it (so ideally just put these extern template definitions in the header). Then in some other compilation unit you should explicitly instantiate it by calling `template` on it. *Now what is the purpose of all this? By instantiating the template in a different compilation unit, you can compile the instance differently from all the others and still use it!*.

# `-march`
Specifies the microarchitecture for which to compile. This means that the generated instructions may not run on a processor that is not the one indicated. By default it targets the processor type of the compiling machine, which means on most desktop computers it'll be `x86-64` (which specifies a generic `x86-64` cpu and thus produces a binary that is pretty widely compatible.)